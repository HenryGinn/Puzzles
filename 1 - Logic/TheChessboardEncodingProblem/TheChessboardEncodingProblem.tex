\subsection{The Chessboard Encoding Problem}

This problem is from a collaboration between 3blue1brown and Matt Parker. I attempted this problem years ago, but could not do it, but on a second attempt recently I got it instanteously. I think I spoiled this problem for myself however as I had watched a video recently about a highly relevant problem, and I would never have got it so fast otherwise. I give this problem a difficulty of 5/10, although the ideas behind the solution did lead to someone winning the Turing Prize.

You and a colleague are inprisoned, although the prison warden gives you an opportunity for freedom. There is an $8 \times 8$ chessboard where each square is a hidden compartment, and the warden reveals to one of you, let us call them person A, which square the key to the door is hidden in. A coin is then placed on each square in a configuration decided by the warden that is not known to you or your colleague in advance. Person A has to turn over exactly one coin before leaving the room, at which point person B enters and needs to determine which square has the key. You are allowed to agree a strategy beforehand, although the warden will hear your strategy, and will try and find a configuration of coins to make your strategy not work.

\textbf{Hints:}

\begin{enumerate}
	\item Consider a board with two squares, then four squares.
	\item There exists a reliable strategy if and only if the number of squares is a power of two~\cite{}.
	\item Consider the parity of the number of coins that are heads-up in a region.
\end{enumerate}

\textbf{Solution:}

The solution works by being able to control the parity of the number of heads-up coins in six regions. This produces a six-digit binary number which can be used to encode a square of the chessboard as $8 \times 8 = 64 = 2^6$. The key is to be able to control the parity in each region indepently, and the six regions shown in figure~\ref{fig:TheChessboardEncodingProblem_Grids} allow this.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[scale=0.6]
			\input{1 - Logic/TheChessboardEncodingProblem/Chessboard_1.tikz}
		\end{tikzpicture}\hspace{5mm}
		\begin{tikzpicture}[scale=0.6]
			\input{1 - Logic/TheChessboardEncodingProblem/Chessboard_2.tikz}
		\end{tikzpicture}\hspace{5mm}
		\begin{tikzpicture}[scale=0.6]
			\input{1 - Logic/TheChessboardEncodingProblem/Chessboard_3.tikz}
		\end{tikzpicture}\vspace{6mm}
		\\
		\begin{tikzpicture}[scale=0.6]
			\input{1 - Logic/TheChessboardEncodingProblem/Chessboard_4.tikz}
		\end{tikzpicture}\hspace{5mm}
		\begin{tikzpicture}[scale=0.6]
			\input{1 - Logic/TheChessboardEncodingProblem/Chessboard_5.tikz}
		\end{tikzpicture}\hspace{5mm}
		\begin{tikzpicture}[scale=0.6]
			\input{1 - Logic/TheChessboardEncodingProblem/Chessboard_6.tikz}
		\end{tikzpicture}
	\end{center}
	\caption{Six regions that each define a binary bit via the parity of the number of heads-up coins in the squares highlighted in red.}
	\label{fig:TheChessboardEncodingProblem_Grids}
\end{figure}

In the example shown in figure~\ref{fig:TheChessboardEncodingProblem_Example} the key has been hidden in the cell in the third row and seventh column. Using the first three digits to encode the column number and the last three digits to encode the row number, this is encoded as 111011. In the red highlighted region in figure~\ref{fig:TheChessboardEncodingProblem_1} there are 19 heads which is equal to 1 modulo 2. This matches the first digit in the number we want to encode which means we want to preserve the parity of heads in this region. Therefore we will flip a coin outside the red highlighted region, that is, on the left hand side. We can do a similar process for the other regions and the results of this are given in table~\ref{tab:TheChessboardEncodingProblem_ExampleParity}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[scale=1]
		\input{1 - Logic/TheChessboardEncodingProblem/ChessboardExample.tikz}
	\end{tikzpicture}
	\caption{An example of random coins on a chessboard. The red highlighted square indicates the position of the key.}
	\label{fig:TheChessboardEncodingProblem_Example}
\end{figure}

\begin{table}[H]
	\centering
	\caption{An example of how to determine which regions to flip the parity of}
	\label{tab:TheChessboardEncodingProblem_ExampleParity}
	\begin{tabular}{cccccc}
		\myhline
		Region & Head Count & Head Parity & Encoded Parity & Parity Change & Flip Red Region  \\
		\myhline
		\tableinput{1 - Logic/TheChessboardEncodingProblem/ChessboardExampleTable.tex}
		\myhline
	\end{tabular}
\end{table}

Reading from the last column, we need to flip the coin with encoding 001011 which is the the second column and third row. Once this is done, the parities of the different regions would be read off as 111011, precisely giving the position of the square with the hidden key. Note that the position of the coin to flip is given by the XOR of the state encoded by the position of the hidden key and the state encoded by the board.

\textbf{Extensions and Comments:}

We notice that as there are $2^6$ different states to encode and $2^{64}$ boards, there must be $2^6$ sets of $2^{58}$ elements that are equivalent in some sense. We can make this intuition more rigorous. Consider the set of 64-tuples of binary numbers, $G = \{ 0, 1 \}^{64}$. For $x, y \in G$ we can define the binary option, $x \circ y := (x + y) \mod 2$, and note that this is equivalent to elementwise XOR. This can easily be seen to form an abelian group. Elements of this group represent states of the board. We can also make a group where each element corresponds to a square on the board.

Define $f(x)$ to be the function that takes $x$ to the index of the cell that it encodes. With an abuse of notation using $\sum$ to mean repeated application of $\circ$, we can give this function explicitly as $f(x) = \sum_{i \in I_k} x_i$ where $I_k$ is the indexing set corresponding to the $k^\text{th}$ digit in the encoding. If we define $K := \ker{f}$ then it follows from the first isomorphism theorem that $K$ is a normal subgroup of $G$ and the quotient group $H = G / K$ is well-defined. $K$ represents all the board states that encode $0$ and we are dividing out this information. This means that we expect each element of $H$ to represent all the board states that encodes the same square.

We could arrive at the same group through a congruence. Define an equivalence relation between board states where two states are equivalent if they encode the same cell, that is, $x \sim y \iff f(x) = f(y)$. It is easy to show this is an equivalence as the equivalency axioms are inherited from the equality relation. Equation~\eqref{eqn:TheChessboardEncodingProblem_SelfInverse} demonstrates that mapped elements are self-inverse from which if follows in equation~\eqref{eqn:TheChessboardEncodingProblem_CongruenceRespectsInverses} that the congruence relation respects inverses. Equation \eqref{eqn:TheChessboardEncodingProblem_LinearityOfF} shows that $f$ is linear and thus the congruence respects the binary operation as well, as shown in \eqref{eqn:TheChessboardEncodingProblem_CongruenceRespectsProducts}. This is essentially equivalent to saying that flipping the parity of a coin within a region flips the parity of the whole region.

\begin{subequations}
	\begin{align}
		\notag\\[-6mm]
		\begin{split}
			f(x) \circ f(x) = 0 &\implies f(x) = f(x)^{-1}
			\label{eqn:TheChessboardEncodingProblem_SelfInverse}
		\end{split}\\[2mm]
		\begin{split}
			f(x) = f(y) &\implies f(x)^{-1} = f(y)^{-1}
			\label{eqn:TheChessboardEncodingProblem_CongruenceRespectsInverses}
		\end{split}\\[2mm]
		\begin{split}
			f(x)_k \circ f(y)_k = \sum_{i \in I_k} x_i \circ \sum_{i \in I_k} y_i &= \sum_{i \in I_k} x_i \circ y_i = \sum_{i \in I_k} (x \circ y)_i = f(x \circ y)_k
			\label{eqn:TheChessboardEncodingProblem_LinearityOfF}
		\end{split}\\[-6mm]\notag
	\end{align}
	
	\begin{equation}
		\begin{aligned}
			x^1 \sim y^1,\, x^2 \sim y^2 &\implies f(x^1) = f(y^1),\, f(x^2) = f(y^2)  \\
			&\implies f(x^1 \circ x^2)_k = f(x^1) \circ f(x^2) = f(y^1) \circ f(y^2) = f(y^1 \circ y^2)  \\
			&\implies x^1 \circ x^2 \sim y^1 \circ y^2
		\end{aligned}
		\label{eqn:TheChessboardEncodingProblem_CongruenceRespectsProducts}
	\end{equation}
\end{subequations}